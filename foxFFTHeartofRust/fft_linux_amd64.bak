//go:build (linux && amd64) || (darwin && amd64)

package foxFFTHeartofRust

/*
#cgo linux,amd64 LDFLAGS: -L${SRCDIR}/libs/linux_amd64 -lrustfft -lm -ldl
#cgo darwin,amd64 LDFLAGS: -L${SRCDIR}/libs/darwin_amd64 -lrustfft

#include <stdlib.h>

extern void fft_forward(const double* input_real, const double* input_imag, double* output_real, double* output_imag, size_t n);
extern void fft_inverse(const double* input_real, const double* input_imag, double* output_real, double* output_imag, size_t n);
*/
import "C"
import "unsafe"

func init() {
	fftForward = fftForwardImpl
	fftInverse = fftInverseImpl
}

func fftForwardImpl(data []complex128) {
	n := len(data)
	if n == 0 {
		return
	}

	inputReal := make([]float64, n)
	inputImag := make([]float64, n)
	for i, c := range data {
		inputReal[i] = real(c)
		inputImag[i] = imag(c)
	}

	outputReal := make([]float64, n)
	outputImag := make([]float64, n)

	C.fft_forward(
		(*C.double)(unsafe.Pointer(&inputReal[0])),
		(*C.double)(unsafe.Pointer(&inputImag[0])),
		(*C.double)(unsafe.Pointer(&outputReal[0])),
		(*C.double)(unsafe.Pointer(&outputImag[0])),
		C.size_t(n),
	)

	for i := 0; i < n; i++ {
		data[i] = complex(outputReal[i], outputImag[i])
	}
}

func fftInverseImpl(data []complex128) {
	n := len(data)
	if n == 0 {
		return
	}

	inputReal := make([]float64, n)
	inputImag := make([]float64, n)
	for i, c := range data {
		inputReal[i] = real(c)
		inputImag[i] = imag(c)
	}

	outputReal := make([]float64, n)
	outputImag := make([]float64, n)

	C.fft_inverse(
		(*C.double)(unsafe.Pointer(&inputReal[0])),
		(*C.double)(unsafe.Pointer(&inputImag[0])),
		(*C.double)(unsafe.Pointer(&outputReal[0])),
		(*C.double)(unsafe.Pointer(&outputImag[0])),
		C.size_t(n),
	)

	for i := 0; i < n; i++ {
		data[i] = complex(outputReal[i], outputImag[i])
	}
}
